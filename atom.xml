<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joker&#39;s Personal Website</title>
  
  <subtitle>只有那些疯狂到认为自己可以改变世界的人&lt;br/&gt;才可以真的改变世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-03T04:36:08.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Joker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开放API接口签名验证</title>
    <link href="http://yoursite.com/2018/02/02/%E5%BC%80%E6%94%BEAPI%E6%8E%A5%E5%8F%A3%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/"/>
    <id>http://yoursite.com/2018/02/02/开放API接口签名验证/</id>
    <published>2018-02-02T06:46:08.000Z</published>
    <updated>2018-02-03T04:36:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接口安全问题"><a href="#接口安全问题" class="headerlink" title="接口安全问题"></a>接口安全问题</h3><ul><li>请求身份是否合法？  </li><li>请求参数是否被篡改？  </li><li>请求是否唯一？</li></ul><h3 id="AccessKey-amp-SecretKey-（开放平台）"><a href="#AccessKey-amp-SecretKey-（开放平台）" class="headerlink" title="AccessKey&amp;SecretKey （开放平台）"></a>AccessKey&amp;SecretKey （开放平台）</h3><h4 id="请求身份"><a href="#请求身份" class="headerlink" title="请求身份"></a>请求身份</h4><p>为开发者分配<strong>AccessKey</strong>（开发者标识，确保唯一）和<strong>SecretKey</strong>（用于接口加密，确保不易被穷举，生成算法不易被猜测）。  </p><h4 id="防止篡改"><a href="#防止篡改" class="headerlink" title="防止篡改"></a>防止篡改</h4><p><strong>参数签名</strong></p><ol><li>按照请求参数名的字母升序排列非空请求参数（包含AccessKey），使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串stringA；</li><li>在stringA最后拼接上Secretkey得到字符串stringSignTemp；</li><li>对stringSignTemp进行MD5运算，并将得到的字符串所有字符转换为大写，得到sign值。  </li></ol><p>请求携带参数<strong>AccessKey</strong>和<strong>Sign</strong>，只有拥有合法的身份AccessKey和正确的签名Sign才能放行。这样就解决了身份验证和参数篡改问题，即使请求参数被劫持，由于获取不到SecretKey（<strong>仅作本地加密使用，不参与网络传输</strong>），无法伪造合法的请求。</p><h4 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h4><p>虽然解决了请求参数被篡改的隐患，但是还存在着重复使用请求参数伪造二次请求的隐患。</p><p><strong>timestamp+nonce方案</strong>  </p><p>nonce指<strong>唯一的随机字符串</strong>，用来标识每个被签名的请求。通过为每个请求提供一个唯一的标识符，服务器能够防止请求被多次使用（记录所有用过的nonce以阻止它们被二次使用）。  </p><p>然而，对服务器来说永久存储所有接收到的nonce的代价是非常大的。可以使用<strong>timestamp来优化nonce的存储</strong>。</p><p>假设允许客户端和服务端最多能存在15分钟的时间差，同时追踪记录在服务端的nonce集合。当有新的请求进入时，首先检查携带的timestamp是否在15分钟内，如超出时间范围，则拒绝，然后查询携带的nonce，如存在已有集合，则拒绝。否则，记录该nonce，并删除集合内时间戳大于15分钟的nonce（可以使用redis的expire，新增nonce的同时设置它的超时失效时间为15分钟）。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><code>请求接口：http://api.test.com/test?name=hello&amp;home=world&amp;work=java</code></p><ul><li><p>客户端  </p><ol><li>生成当前时间戳timestamp=now和唯一随机字符串nonce=random</li><li>按照请求参数名的字母升序排列非空请求参数（包含AccessKey)<br> <code>stringA=&quot;AccessKey=access&amp;home=world&amp;name=hello&amp;work=java&amp;timestamp=now&amp;nonce=random&quot;;</code></li><li>拼接密钥SecretKey<br> <code>stringSignTemp=&quot;AccessKey=access&amp;home=world&amp;name=hello&amp;work=java&amp;timestamp=now&amp;nonce=random&amp;SecretKey=secret&quot;;</code>  </li><li>MD5并转换为大写<br><code>sign = MD5(stringSignTemp).toUpperCase();</code></li><li>最终请求<br> <code>http://api.test.com/test?name=hello&amp;home=world&amp;work=java&amp;timestamp=now&amp;nonce=nonce&amp;sign=sign;</code></li></ol></li><li><p>服务端<br>  <img src="/2018/02/02/开放API接口签名验证/1.png" alt="服务端流程">{:style=”zoom:50%”}</p></li></ul><h3 id="Token-amp-AppKey（APP）"><a href="#Token-amp-AppKey（APP）" class="headerlink" title="Token&amp;AppKey（APP）"></a>Token&amp;AppKey（APP）</h3><p>在APP开放API接口的设计中，由于大多数接口涉及到用户的个人信息以及产品的敏感数据，所以要对这些接口进行身份验证，为了安全起见让用户暴露的明文密码次数越少越好，然而客户端与服务器的交互在请求之间是无状态的，也就是说，当涉及到用户状态时，每次请求都要带上身份验证信息。</p><h4 id="Token身份验证"><a href="#Token身份验证" class="headerlink" title="Token身份验证"></a>Token身份验证</h4><ol><li>用户登录向服务器提供认证信息（如账号和密码），服务器验证成功后<strong>返回Token</strong>给客户端；</li><li>客户端将Token保存在本地，后续发起请求时，<strong>携带此Token</strong>；</li><li>服务器检查Token的有效性，有效则放行，无效（Token错误或过期）则拒绝。</li></ol><p><strong>安全隐患</strong>：Token被劫持，伪造请求和篡改参数。</p><h4 id="Token-AppKey签名验证"><a href="#Token-AppKey签名验证" class="headerlink" title="Token+AppKey签名验证"></a>Token+AppKey签名验证</h4><p>与上面开发平台的验证方式类似，为客户端分配<strong>AppKey</strong>（密钥，用于接口加密，不参与传输），将AppKey和所有请求参数组合成源串，根据<strong>签名算法</strong>生成签名值，发送请求时将签名值一起发送给服务器验证。这样，即使Token被劫持，对方不知道AppKey和签名算法，就无法伪造请求和篡改参数。再结合上述的<strong>重发攻击</strong>解决方案，即使请求参数被劫持也无法伪造二次重复请求。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><h5 id="登陆和退出请求"><a href="#登陆和退出请求" class="headerlink" title="登陆和退出请求"></a>登陆和退出请求</h5><p><img src="/2018/02/02/开放API接口签名验证/2.png" alt="登陆和退出流程">  </p><h5 id="后续请求"><a href="#后续请求" class="headerlink" title="后续请求"></a>后续请求</h5><ul><li><p>客户端<br>  和上述开放平台的客户端行为类似，把AccessKey改为token即可。</p></li><li><p>服务端<br>  <img src="/2018/02/02/开放API接口签名验证/3.png" alt="服务端流程"></p></li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>请移步<a href="https://github.com/Joker-Coder/awesome-pay" target="_blank" rel="noopener">聚合支付平台</a>，站长正在开发的一款开源项目，其中接口验证采用的就是上文中开放平台的验证方案，欢迎大家Star!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;接口安全问题&quot;&gt;&lt;a href=&quot;#接口安全问题&quot; class=&quot;headerlink&quot; title=&quot;接口安全问题&quot;&gt;&lt;/a&gt;接口安全问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;请求身份是否合法？  &lt;/li&gt;
&lt;li&gt;请求参数是否被篡改？  &lt;/li&gt;
&lt;li&gt;请求是否唯
      
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="接口" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="签名" scheme="http://yoursite.com/tags/%E7%AD%BE%E5%90%8D/"/>
    
      <category term="加密" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="token" scheme="http://yoursite.com/tags/token/"/>
    
  </entry>
  
</feed>
