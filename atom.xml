<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joker&#39;s Personal Website</title>
  
  <subtitle>只有那些疯狂到认为自己可以改变世界的人&lt;br/&gt;才可以真的改变世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-07T12:26:45.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Joker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>突破微信小程序模板消息限制，实现无限制主动推送</title>
    <link href="http://yoursite.com/post/b56ae4d7.html"/>
    <id>http://yoursite.com/post/b56ae4d7.html</id>
    <published>2018-02-07T12:12:59.000Z</published>
    <updated>2018-02-07T12:26:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>  基于微信的通知渠道，微信小程序为开发者提供了可以高效触达用户的模板消息能力，在用户本人与小程序页面有交互行为后触发。通过提交表单来下发模板消息的限制为“允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下发条数独立，相互不影响）”。</p><a id="more"></a><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>基于微信的通知渠道，微信小程序为开发者提供了可以高效触达用户的模板消息能力，<strong>在用户本人与小程序页面有交互行为后触发</strong>，通过微信聊天列表中的服务通知可快捷进入查看消息，点击查看详情还能跳转到下发消息的小程序的指定页面。  </p><p>微信小程序允许下发模板消息的条件分为两类：支付或者提交表单。通过提交表单来下发模板消息的限制为“允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下发条数独立，相互不影响）”。  </p><p>然而，<strong>用户1次触发7天内推送1条通知是明显不够用的</strong>。比如，签到功能利用模板消息的推送来提醒用户每天签到，只能在用户前一天签到的情况下，获取一次推送模板消息的机会，然后用于第二天向该用户发送签到提醒。但是很多情况下，用户在某一天忘记签到，系统便失去了提醒用户的权限，导致和用户断开了联系；再比如，系统想主动告知用户即将做某活动，然而由于微信小程序<strong>被动触发通知的限制</strong>，系统将无法主动推送消息。</p><h3 id="如何突破模板消息的推送限制？"><a href="#如何突破模板消息的推送限制？" class="headerlink" title="如何突破模板消息的推送限制？"></a>如何突破模板消息的推送限制？</h3><p><strong>突破口：“1次提交表单可下发1条，多次提交下发条数独立，相互不影响”</strong>  </p><p>为了突破模板消息的推送限制，实现<strong>7天内任性推送</strong>，只需收集到足够的推送码，即每次提交表单时获取到的formId。一个formId代表着开发者有向<b>当前用户</b>推送模板消息的<b>一次权限</b>。</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><h5 id="收集推送码"><a href="#收集推送码" class="headerlink" title="收集推送码"></a>收集推送码</h5><p>当表单组件中的属性report-submit=true时表示发送模板消息，提交表单便可以获取formId。接下来只要对原先的页面进行改造，将用户原先绑定了点击事件的界面用表单组件中的button按钮组件来代替，即把用户的交互点击的bindtap事件由表单bindsubmit来代替，从而捕获用户的点击事件来生成更多的推送码。  </p><pre>// 收集推送码Page({    formSubmit: funcition(e) {        let formId = e.detail.formId;        this.collectFormIds(formId);  //保存推送码        let type = e.detail.target.dataset.type; // 根据type执行点击事件    },    collectFormIds: function(formId) {         let formIds = app.globalData.globalFormIds;  // 获取全局推送码数组        if (!formIds)            formIds = [];        let data = {            formId: formId,            expire: new Data().getTime() + 60480000  // 7天后的过期时间戳        }        formIds.push(data);        app.globalData.globalFormIds = formIds;    },})</pre><h5 id="上报推送码"><a href="#上报推送码" class="headerlink" title="上报推送码"></a>上报推送码</h5><p>等待用户下一次发起网络请求时，将globalFormIds发送给服务器。  </p><pre>// 上报推送码Page({    onLoad: funcition(e) {        this.uploadFormIds();  //上传推送码    },    collectFormIds: function(formId) {         var formIds = app.globalData.globalFormIds;  // 获取全局推送码        if (formIds.length) {             formIds = JSON.stringify(formIds);  // 转换成JSON字符串             app.globalData.gloabalFomIds = '';  // 清空当前全局推送码        }        wx.request({  // 发送到服务器            url: 'http://xxx',            method: 'POST',            data: {                openId: 'openId',                formIds: formIds            },            success: function(res) {            }        });    },})</pre><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><h5 id="存储推送码"><a href="#存储推送码" class="headerlink" title="存储推送码"></a>存储推送码</h5><p>高频IO，采用Redis来存储推送码。  </p><pre>/** * 收集用户推送码 * * @param openId        用户的openid * @param formTemplates 用户的表单模板 */public void collect(String openId, List<formtemplatevo> formTemplates) {    redisTemplate.opsForList().rightPushAll("mina:openid:" + openId, formTemplates);}</formtemplatevo></pre><h5 id="推送模板消息"><a href="#推送模板消息" class="headerlink" title="推送模板消息"></a>推送模板消息</h5><p>下面实现了群发的功能，针对特定用户类似。</p><pre>/** * 推送消息 * * @param templateId 模板消息id * @param page       跳转页面 * @param keyWords   模板内容 */public void push(String templateId, String page, String keyWords) {    String logPrefix = "推送消息";    // 获取access token    String accessToken = this.getAccessToken();    // 创建消息通用模板    MsgTemplateVO msgTemplateVO = MsgTemplateVO.builder().template_id(templateId).build();    // 跳转页面    msgTemplateVO.setPage(StringUtils.isNotBlank(page) ? page : "");    // 模板内容    if (StringUtils.isNotBlank(keyWords)) {        String[] keyWordArr = keyWords.split(BaseConsts.COMMA_STR);        Map<string, msgtemplatevo.keyword=""> keyWordMap = new HashMap<>(8);        for (int i = 0; i < keyWordArr.length; i++) {            MsgTemplateVO.KeyWord keyWord = msgTemplateVO.new KeyWord(keyWordArr[i]);            keyWordMap.put(MsgTemplateVO.KEYWORD + (i + 1), keyWord);        }        msgTemplateVO.setData(keyWordMap);    } else {        msgTemplateVO.setData(Collections.emptyMap());    }    // 获取所有用户    List<string> openIdList = minaRedisDao.getAllOpenIds();    for (String openId : openIdList) {        // 获取有效推送码        String formId = minaRedisDao.getValidFormId(openId);        if (StringUtils.isBlank(formId)) {            LOGGER.error("{}>>>openId={}>>>已无有效推送码[失败]", logPrefix, openId);            continue;        }        // 指派消息        MsgTemplateVO assignMsgTemplateVO = msgTemplateVO.assign(openId, formId);        // 发送消息        Map<string, object=""> resultMap;        try {            String jsonBody = JsonUtils.getObjectMapper().writeValueAsString(assignMsgTemplateVO);            String resultBody = OkHttpUtils.getInstance().postAsString(messageUrl + accessToken, jsonBody);            resultMap = JsonUtils.getObjectMapper().readValue(resultBody, Map.class);        } catch (IOException e) {            LOGGER.error("{}>>>openId={}>>>{}[失败]", logPrefix, openId, e.getMessage(), e);            continue;        }        if ((int) resultMap.get(ResponseConsts.Mina.CODE) != 0) {            LOGGER.error("{}>>>openId={}>>>{}[失败]", logPrefix, openId, resultMap.get(ResponseConsts.Mina.MSG));            continue;        }        LOGGER.info("{}>>>openId={}>>>[成功]", logPrefix, openId);    }}/** * 根据用户获取有效的推送码 * * @param openId 用户的openid * @return 推送码 */public String getValidFormId(String openId) {    List<formtemplatevo> formTemplates = redisTemplate.opsForList().range("mina:openid:" + openId, 0, -1);    String validFormId = "";    int trimStart = 0;    int size;    for (int i = 0; i < (size = formTemplates.size()); i++) {        if (formTemplates.get(i).getExpire() > System.currentTimeMillis()) {            validFormId = formTemplates.get(i).getFormId();            trimStart = i + 1;            break;        }    }    // 移除本次使用的和已过期的    redisTemplate.opsForList().trim(KEY_MINA_PUSH + openId, trimStart == 0 ? size : trimStart, -1);    return validFormId;}</formtemplatevo></string,></string></string,></pre><p>以上方案可以在用户<strong>最后一次使用小程序后的7天内</strong>，对用户发送多条模板消息唤回用户。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  基于微信的通知渠道，微信小程序为开发者提供了可以高效触达用户的模板消息能力，在用户本人与小程序页面有交互行为后触发。通过提交表单来下发模板消息的限制为“允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下发条数独立，相互不影响）”。&lt;/p&gt;
    
    </summary>
    
      <category term="随记" scheme="http://yoursite.com/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="消息推送" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
    
      <category term="模板消息" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>开放API接口签名验证,让你的接口从此不再裸奔</title>
    <link href="http://yoursite.com/post/c60272bf.html"/>
    <id>http://yoursite.com/post/c60272bf.html</id>
    <published>2018-02-02T06:46:08.000Z</published>
    <updated>2018-02-07T12:29:38.000Z</updated>
    
    <content type="html"><![CDATA[<center><br>接口安全问题<br>请求身份是否合法？  请求参数是否被篡改？  请求是否唯一？<br></center><a id="more"></a><h3 id="接口安全问题"><a href="#接口安全问题" class="headerlink" title="接口安全问题"></a>接口安全问题</h3><ul><li>请求身份是否合法？  </li><li>请求参数是否被篡改？  </li><li>请求是否唯一？</li></ul><h3 id="AccessKey-amp-SecretKey-（开放平台）"><a href="#AccessKey-amp-SecretKey-（开放平台）" class="headerlink" title="AccessKey&amp;SecretKey （开放平台）"></a>AccessKey&amp;SecretKey （开放平台）</h3><h4 id="请求身份"><a href="#请求身份" class="headerlink" title="请求身份"></a>请求身份</h4><p>为开发者分配<strong>AccessKey</strong>（开发者标识，确保唯一）和<strong>SecretKey</strong>（用于接口加密，确保不易被穷举，生成算法不易被猜测）。  </p><h4 id="防止篡改"><a href="#防止篡改" class="headerlink" title="防止篡改"></a>防止篡改</h4><p><strong>参数签名</strong></p><ol><li>按照请求参数名的字母升序排列非空请求参数（包含AccessKey），使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串stringA；</li><li>在stringA最后拼接上Secretkey得到字符串stringSignTemp；</li><li>对stringSignTemp进行MD5运算，并将得到的字符串所有字符转换为大写，得到sign值。  </li></ol><p>请求携带参数<strong>AccessKey</strong>和<strong>Sign</strong>，只有拥有合法的身份AccessKey和正确的签名Sign才能放行。这样就解决了身份验证和参数篡改问题，即使请求参数被劫持，由于获取不到SecretKey（<strong>仅作本地加密使用，不参与网络传输</strong>），无法伪造合法的请求。</p><h4 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h4><p>虽然解决了请求参数被篡改的隐患，但是还存在着重复使用请求参数伪造二次请求的隐患。</p><p><strong>timestamp+nonce方案</strong>  </p><p>nonce指<strong>唯一的随机字符串</strong>，用来标识每个被签名的请求。通过为每个请求提供一个唯一的标识符，服务器能够防止请求被多次使用（记录所有用过的nonce以阻止它们被二次使用）。  </p><p>然而，对服务器来说永久存储所有接收到的nonce的代价是非常大的。可以使用<strong>timestamp来优化nonce的存储</strong>。</p><p>假设允许客户端和服务端最多能存在15分钟的时间差，同时追踪记录在服务端的nonce集合。当有新的请求进入时，首先检查携带的timestamp是否在15分钟内，如超出时间范围，则拒绝，然后查询携带的nonce，如存在已有集合，则拒绝。否则，记录该nonce，并删除集合内时间戳大于15分钟的nonce（可以使用redis的expire，新增nonce的同时设置它的超时失效时间为15分钟）。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><code>请求接口：http://api.test.com/test?name=hello&amp;home=world&amp;work=java</code></p><ul><li><p>客户端<br>  1.生成当前时间戳timestamp=now和唯一随机字符串nonce=random<br>  2.按照请求参数名的字母升序排列非空请求参数（包含AccessKey)<br>  <code>stringA=&quot;AccessKey=access&amp;home=world&amp;name=hello&amp;work=java&amp;timestamp=now&amp;nonce=random&quot;;</code><br>  3.拼接密钥SecretKey<br>  <code>stringSignTemp=&quot;AccessKey=access&amp;home=world&amp;name=hello&amp;work=java&amp;timestamp=now&amp;nonce=random&amp;SecretKey=secret&quot;;</code><br>  4.MD5并转换为大写<br>  <code>sign=MD5(stringSignTemp).toUpperCase();</code><br>  5.最终请求<br>  <code>http://api.test.com/test?name=hello&amp;home=world&amp;work=java&amp;timestamp=now&amp;nonce=nonce&amp;sign=sign;</code></p></li><li><p>服务端<br>  <img src="c60272bf/1.png" alt="服务端流程"></p></li></ul><h3 id="Token-amp-AppKey（APP）"><a href="#Token-amp-AppKey（APP）" class="headerlink" title="Token&amp;AppKey（APP）"></a>Token&amp;AppKey（APP）</h3><p>在APP开放API接口的设计中，由于大多数接口涉及到用户的个人信息以及产品的敏感数据，所以要对这些接口进行身份验证，为了安全起见让用户暴露的明文密码次数越少越好，然而客户端与服务器的交互在请求之间是无状态的，也就是说，当涉及到用户状态时，每次请求都要带上身份验证信息。</p><h4 id="Token身份验证"><a href="#Token身份验证" class="headerlink" title="Token身份验证"></a>Token身份验证</h4><ol><li>用户登录向服务器提供认证信息（如账号和密码），服务器验证成功后<strong>返回Token</strong>给客户端；</li><li>客户端将Token保存在本地，后续发起请求时，<strong>携带此Token</strong>；</li><li>服务器检查Token的有效性，有效则放行，无效（Token错误或过期）则拒绝。</li></ol><p><strong>安全隐患</strong>：Token被劫持，伪造请求和篡改参数。</p><h4 id="Token-AppKey签名验证"><a href="#Token-AppKey签名验证" class="headerlink" title="Token+AppKey签名验证"></a>Token+AppKey签名验证</h4><p>与上面开发平台的验证方式类似，为客户端分配<strong>AppKey</strong>（密钥，用于接口加密，不参与传输），将AppKey和所有请求参数组合成源串，根据<strong>签名算法</strong>生成签名值，发送请求时将签名值一起发送给服务器验证。这样，即使Token被劫持，对方不知道AppKey和签名算法，就无法伪造请求和篡改参数。再结合上述的<strong>重发攻击</strong>解决方案，即使请求参数被劫持也无法伪造二次重复请求。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><h5 id="登陆和退出请求"><a href="#登陆和退出请求" class="headerlink" title="登陆和退出请求"></a>登陆和退出请求</h5><p><img src="c60272bf/2.png" alt="登陆和退出流程">  </p><h5 id="后续请求"><a href="#后续请求" class="headerlink" title="后续请求"></a>后续请求</h5><ul><li><p>客户端<br>  和上述开放平台的客户端行为类似，把AccessKey改为token即可。</p></li><li><p>服务端<br>  <img src="c60272bf/3.png" alt="服务端流程"></p></li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>请移步<strong><a href="https://github.com/Joker-Coder/awesome-pay" target="_blank" rel="noopener">聚合支付平台</a></strong>，站长正在开发的一款开源项目，其中接口验证采用的就是上文中开放平台的验证方案，欢迎大家Star!</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;br&gt;接口安全问题&lt;br&gt;请求身份是否合法？  请求参数是否被篡改？  请求是否唯一？&lt;br&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="接口" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="签名" scheme="http://yoursite.com/tags/%E7%AD%BE%E5%90%8D/"/>
    
      <category term="加密" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="token" scheme="http://yoursite.com/tags/token/"/>
    
  </entry>
  
</feed>
