<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joker&#39;s Personal Website</title>
  
  <subtitle>只有那些疯狂到认为自己可以改变世界的人&lt;br/&gt;才可以真的改变世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-02T07:44:50.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Joker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开放API接口签名验证</title>
    <link href="http://yoursite.com/2018/02/02/%E5%BC%80%E6%94%BEAPI%E6%8E%A5%E5%8F%A3%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/"/>
    <id>http://yoursite.com/2018/02/02/开放API接口签名验证/</id>
    <published>2018-02-02T06:46:08.000Z</published>
    <updated>2018-02-02T07:44:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接口安全问题"><a href="#接口安全问题" class="headerlink" title="接口安全问题"></a>接口安全问题</h3><ul><li>请求身份是否合法？  </li><li>请求参数是否被篡改？  </li><li>请求是否唯一？</li></ul><h3 id="AccessKey-amp-SecretKey-（开放平台）"><a href="#AccessKey-amp-SecretKey-（开放平台）" class="headerlink" title="AccessKey&amp;SecretKey （开放平台）"></a>AccessKey&amp;SecretKey （开放平台）</h3><h4 id="请求身份"><a href="#请求身份" class="headerlink" title="请求身份"></a>请求身份</h4><p>为开发者分配<strong>AccessKey</strong>（开发者标识，确保唯一）和<strong>SecretKey</strong>（用于接口加密，确保不易被穷举，生成算法不易被猜测）。  </p><h4 id="防止篡改"><a href="#防止篡改" class="headerlink" title="防止篡改"></a>防止篡改</h4><p><strong>参数签名算法</strong></p><ol><li>按照请求参数名的字母升序排列非空请求参数（包含AccessKey），使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串stringA；</li><li>在stringA最后拼接上Secretkey得到字符串stringSignTemp；</li><li>对stringSignTemp进行MD5运算，并将得到的字符串所有字符转换为大写，得到Sign值。  </li></ol><p>请求携带参数<strong>AccessKey</strong>和<strong>Sign</strong>，只有拥有合法的身份AccessKey和正确的签名Sign才能放行。这样就解决了身份验证和参数篡改问题，即使请求参数被劫持，由于获取不到SecretKey（<strong>仅作本地加密使用，不参与网络传输</strong>），无法伪造合法的请求。</p><h4 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h4><p>虽然解决了请求参数被篡改的隐患，但是还存在着重复使用请求参数伪造二次请求的隐患。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li><p>客户端</p></li><li><p>服务端</p></li></ul><h3 id="Token-amp-AppKey（APP）"><a href="#Token-amp-AppKey（APP）" class="headerlink" title="Token&amp;AppKey（APP）"></a>Token&amp;AppKey（APP）</h3><p>在APP开放API接口的设计中，由于大多数接口涉及到用户的个人信息以及产品的敏感数据，所以要对这些接口进行身份验证，为了安全起见让用户暴露的明文密码次数越少越好，然而客户端与服务器的交互在请求之间是无状态的，也就是说，当涉及到用户状态时，每次请求都要带上身份验证信息。</p><h4 id="Token身份验证"><a href="#Token身份验证" class="headerlink" title="Token身份验证"></a>Token身份验证</h4><ol><li>用户登录向服务器提供认证信息（如账号和密码），服务器验证成功后<strong>返回Token</strong>给客户端；</li><li>客户端将Token保存在本地，后续发起请求时，<strong>携带此Token</strong>；</li><li>服务器检查Token的有效性，有效则放行，无效（Token错误或过期）则拒绝。</li></ol><p><strong>安全隐患</strong>：Token被劫持，伪造请求和篡改参数。</p><h4 id="Token-AppKey签名验证"><a href="#Token-AppKey签名验证" class="headerlink" title="Token+AppKey签名验证"></a>Token+AppKey签名验证</h4><p>与上面开发平台的验证方式类似，为客户端分配<strong>AppKey</strong>（密钥，用于接口加密，不参与传输），将AppKey和所有参数组合成源串，根据<strong>签名算法</strong>生成签名值，发送请求时将签名值一起发送给服务器验证。这样，即使Token被劫持，对方不知道AppKey和签名算法，就无法伪造请求和篡改参数。再结合上述的<strong>唯一性</strong>解决方案，即使请求参数被劫持也无法伪造二次重复请求。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><ul><li><p>客户端</p></li><li><p>服务端</p></li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;接口安全问题&quot;&gt;&lt;a href=&quot;#接口安全问题&quot; class=&quot;headerlink&quot; title=&quot;接口安全问题&quot;&gt;&lt;/a&gt;接口安全问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;请求身份是否合法？  &lt;/li&gt;
&lt;li&gt;请求参数是否被篡改？  &lt;/li&gt;
&lt;li&gt;请求是否唯
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="接口" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="签名" scheme="http://yoursite.com/tags/%E7%AD%BE%E5%90%8D/"/>
    
      <category term="加密" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="token" scheme="http://yoursite.com/tags/token/"/>
    
  </entry>
  
</feed>
