<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[突破微信小程序模板消息限制，实现无限制主动推送]]></title>
    <url>%2Fpost%2Fb56ae4d7.html</url>
    <content type="text"><![CDATA[基于微信的通知渠道，微信小程序为开发者提供了可以高效触达用户的模板消息能力，在用户本人与小程序页面有交互行为后触发。通过提交表单来下发模板消息的限制为“允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下发条数独立，相互不影响）”。 需求背景基于微信的通知渠道，微信小程序为开发者提供了可以高效触达用户的模板消息能力，在用户本人与小程序页面有交互行为后触发，通过微信聊天列表中的服务通知可快捷进入查看消息，点击查看详情还能跳转到下发消息的小程序的指定页面。 微信小程序允许下发模板消息的条件分为两类：支付或者提交表单。通过提交表单来下发模板消息的限制为“允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下发条数独立，相互不影响）”。 然而，用户1次触发7天内推送1条通知是明显不够用的。比如，签到功能利用模板消息的推送来提醒用户每天签到，只能在用户前一天签到的情况下，获取一次推送模板消息的机会，然后用于第二天向该用户发送签到提醒。但是很多情况下，用户在某一天忘记签到，系统便失去了提醒用户的权限，导致和用户断开了联系；再比如，系统想主动告知用户即将做某活动，然而由于微信小程序被动触发通知的限制，系统将无法主动推送消息。 如何突破模板消息的推送限制？突破口：“1次提交表单可下发1条，多次提交下发条数独立，相互不影响” 为了突破模板消息的推送限制，实现7天内任性推送，只需收集到足够的推送码，即每次提交表单时获取到的formId。一个formId代表着开发者有向当前用户推送模板消息的一次权限。 客户端收集推送码当表单组件中的属性report-submit=true时表示发送模板消息，提交表单便可以获取formId。接下来只要对原先的页面进行改造，将用户原先绑定了点击事件的界面用表单组件中的button按钮组件来代替，即把用户的交互点击的bindtap事件由表单bindsubmit来代替，从而捕获用户的点击事件来生成更多的推送码。 1234567891011121314151617181920// 收集推送码Page(&#123; formSubmit: funcition(e) &#123; let formId = e.detail.formId; this.collectFormIds(formId); //保存推送码 let type = e.detail.target.dataset.type; // 根据type执行点击事件 &#125;, collectFormIds: function(formId) &#123; let formIds = app.globalData.globalFormIds; // 获取全局推送码数组 if (!formIds) formIds = []; let data = &#123; formId: formId, expire: new Data().getTime() + 60480000 // 7天后的过期时间戳 &#125; formIds.push(data); app.globalData.globalFormIds = formIds; &#125;,&#125;) 上报推送码等待用户下一次发起网络请求时，将globalFormIds发送给服务器。123456789101112131415161718192021222324// 上报推送码Page(&#123; onLoad: funcition(e) &#123; this.uploadFormIds(); //上传推送码 &#125;, collectFormIds: function(formId) &#123; var formIds = app.globalData.globalFormIds; // 获取全局推送码 if (formIds.length) &#123; formIds = JSON.stringify(formIds); // 转换成JSON字符串 app.globalData.gloabalFomIds = ''; // 清空当前全局推送码 &#125; wx.request(&#123; // 发送到服务器 url: 'http://xxx', method: 'POST', data: &#123; openId: 'openId', formIds: formIds &#125;, success: function(res) &#123; &#125; &#125;); &#125;,&#125;) 服务端存储推送码高频IO，采用Redis来存储推送码。123456789/** * 收集用户推送码 * * @param openId 用户的openid * @param formTemplates 用户的表单模板 */public void collect(String openId, List&lt;FormTemplateVO&gt; formTemplates) &#123; redisTemplate.opsForList().rightPushAll("mina:openid:" + openId, formTemplates);&#125; 推送模板消息下面实现了群发的功能，针对特定用户类似。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * 推送消息 * * @param templateId 模板消息id * @param page 跳转页面 * @param keyWords 模板内容 */public void push(String templateId, String page, String keyWords) &#123; String logPrefix = "推送消息"; // 获取access token String accessToken = this.getAccessToken(); // 创建消息通用模板 MsgTemplateVO msgTemplateVO = MsgTemplateVO.builder().template_id(templateId).build(); // 跳转页面 msgTemplateVO.setPage(StringUtils.isNotBlank(page) ? page : ""); // 模板内容 if (StringUtils.isNotBlank(keyWords)) &#123; String[] keyWordArr = keyWords.split(BaseConsts.COMMA_STR); Map&lt;String, MsgTemplateVO.KeyWord&gt; keyWordMap = new HashMap&lt;&gt;(8); for (int i = 0; i &lt; keyWordArr.length; i++) &#123; MsgTemplateVO.KeyWord keyWord = msgTemplateVO.new KeyWord(keyWordArr[i]); keyWordMap.put(MsgTemplateVO.KEYWORD + (i + 1), keyWord); &#125; msgTemplateVO.setData(keyWordMap); &#125; else &#123; msgTemplateVO.setData(Collections.emptyMap()); &#125; // 获取所有用户 List&lt;String&gt; openIdList = minaRedisDao.getAllOpenIds(); for (String openId : openIdList) &#123; // 获取有效推送码 String formId = minaRedisDao.getValidFormId(openId); if (StringUtils.isBlank(formId)) &#123; LOGGER.error("&#123;&#125;&gt;&gt;&gt;openId=&#123;&#125;&gt;&gt;&gt;已无有效推送码[失败]", logPrefix, openId); continue; &#125; // 指派消息 MsgTemplateVO assignMsgTemplateVO = msgTemplateVO.assign(openId, formId); // 发送消息 Map&lt;String, Object&gt; resultMap; try &#123; String jsonBody = JsonUtils.getObjectMapper().writeValueAsString(assignMsgTemplateVO); String resultBody = OkHttpUtils.getInstance().postAsString(messageUrl + accessToken, jsonBody); resultMap = JsonUtils.getObjectMapper().readValue(resultBody, Map.class); &#125; catch (IOException e) &#123; LOGGER.error("&#123;&#125;&gt;&gt;&gt;openId=&#123;&#125;&gt;&gt;&gt;&#123;&#125;[失败]", logPrefix, openId, e.getMessage(), e); continue; &#125; if ((int) resultMap.get(ResponseConsts.Mina.CODE) != 0) &#123; LOGGER.error("&#123;&#125;&gt;&gt;&gt;openId=&#123;&#125;&gt;&gt;&gt;&#123;&#125;[失败]", logPrefix, openId, resultMap.get(ResponseConsts.Mina.MSG)); continue; &#125; LOGGER.info("&#123;&#125;&gt;&gt;&gt;openId=&#123;&#125;&gt;&gt;&gt;[成功]", logPrefix, openId); &#125;&#125;/** * 根据用户获取有效的推送码 * * @param openId 用户的openid * @return 推送码 */public String getValidFormId(String openId) &#123; List&lt;FormTemplateVO&gt; formTemplates = redisTemplate.opsForList().range("mina:openid:" + openId, 0, -1); String validFormId = ""; int trimStart = 0; int size; for (int i = 0; i &lt; (size = formTemplates.size()); i++) &#123; if (formTemplates.get(i).getExpire() &gt; System.currentTimeMillis()) &#123; validFormId = formTemplates.get(i).getFormId(); trimStart = i + 1; break; &#125; &#125; // 移除本次使用的和已过期的 redisTemplate.opsForList().trim(KEY_MINA_PUSH + openId, trimStart == 0 ? size : trimStart, -1); return validFormId;&#125; 以上方案可以在用户最后一次使用小程序后的7天内，对用户发送多条模板消息唤回用户。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>消息推送</tag>
        <tag>模板消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开放API接口签名验证,让你的接口从此不再裸奔]]></title>
    <url>%2Fpost%2Fc60272bf.html</url>
    <content type="text"><![CDATA[接口安全问题请求身份是否合法？ 请求参数是否被篡改？ 请求是否唯一？ 接口安全问题 请求身份是否合法？ 请求参数是否被篡改？ 请求是否唯一？ AccessKey&amp;SecretKey （开放平台）请求身份为开发者分配AccessKey（开发者标识，确保唯一）和SecretKey（用于接口加密，确保不易被穷举，生成算法不易被猜测）。 防止篡改参数签名 按照请求参数名的字母升序排列非空请求参数（包含AccessKey），使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串stringA； 在stringA最后拼接上Secretkey得到字符串stringSignTemp； 对stringSignTemp进行MD5运算，并将得到的字符串所有字符转换为大写，得到sign值。 请求携带参数AccessKey和Sign，只有拥有合法的身份AccessKey和正确的签名Sign才能放行。这样就解决了身份验证和参数篡改问题，即使请求参数被劫持，由于获取不到SecretKey（仅作本地加密使用，不参与网络传输），无法伪造合法的请求。 重放攻击虽然解决了请求参数被篡改的隐患，但是还存在着重复使用请求参数伪造二次请求的隐患。 timestamp+nonce方案 nonce指唯一的随机字符串，用来标识每个被签名的请求。通过为每个请求提供一个唯一的标识符，服务器能够防止请求被多次使用（记录所有用过的nonce以阻止它们被二次使用）。 然而，对服务器来说永久存储所有接收到的nonce的代价是非常大的。可以使用timestamp来优化nonce的存储。 假设允许客户端和服务端最多能存在15分钟的时间差，同时追踪记录在服务端的nonce集合。当有新的请求进入时，首先检查携带的timestamp是否在15分钟内，如超出时间范围，则拒绝，然后查询携带的nonce，如存在已有集合，则拒绝。否则，记录该nonce，并删除集合内时间戳大于15分钟的nonce（可以使用redis的expire，新增nonce的同时设置它的超时失效时间为15分钟）。 实现请求接口：http://api.test.com/test?name=hello&amp;home=world&amp;work=java 客户端 1.生成当前时间戳timestamp=now和唯一随机字符串nonce=random 2.按照请求参数名的字母升序排列非空请求参数（包含AccessKey) stringA=&quot;AccessKey=access&amp;home=world&amp;name=hello&amp;work=java&amp;timestamp=now&amp;nonce=random&quot;; 3.拼接密钥SecretKey stringSignTemp=&quot;AccessKey=access&amp;home=world&amp;name=hello&amp;work=java&amp;timestamp=now&amp;nonce=random&amp;SecretKey=secret&quot;; 4.MD5并转换为大写 sign=MD5(stringSignTemp).toUpperCase(); 5.最终请求 http://api.test.com/test?name=hello&amp;home=world&amp;work=java&amp;timestamp=now&amp;nonce=nonce&amp;sign=sign; 服务端 Token&amp;AppKey（APP）在APP开放API接口的设计中，由于大多数接口涉及到用户的个人信息以及产品的敏感数据，所以要对这些接口进行身份验证，为了安全起见让用户暴露的明文密码次数越少越好，然而客户端与服务器的交互在请求之间是无状态的，也就是说，当涉及到用户状态时，每次请求都要带上身份验证信息。 Token身份验证 用户登录向服务器提供认证信息（如账号和密码），服务器验证成功后返回Token给客户端； 客户端将Token保存在本地，后续发起请求时，携带此Token； 服务器检查Token的有效性，有效则放行，无效（Token错误或过期）则拒绝。 安全隐患：Token被劫持，伪造请求和篡改参数。 Token+AppKey签名验证与上面开发平台的验证方式类似，为客户端分配AppKey（密钥，用于接口加密，不参与传输），将AppKey和所有请求参数组合成源串，根据签名算法生成签名值，发送请求时将签名值一起发送给服务器验证。这样，即使Token被劫持，对方不知道AppKey和签名算法，就无法伪造请求和篡改参数。再结合上述的重发攻击解决方案，即使请求参数被劫持也无法伪造二次重复请求。 实现登陆和退出请求 后续请求 客户端 和上述开放平台的客户端行为类似，把AccessKey改为token即可。 服务端 源码请移步聚合支付平台，站长正在开发的一款开源项目，其中接口验证采用的就是上文中开放平台的验证方案，欢迎大家Star!]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>接口</tag>
        <tag>签名</tag>
        <tag>加密</tag>
        <tag>算法</tag>
        <tag>token</tag>
      </tags>
  </entry>
</search>
